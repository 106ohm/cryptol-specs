// NIST Prime Field Elliptic Curves defined in FIPS-186-4

module Common::EC::PrimeField::PFEC where

parameter
    type P : #     //  The prime modulus
    type constraint (fin P, P >= 5)
    n  : Integer   //  Prime order of generator G
    b  : Z P       //  Curve coefficient
    Gx : Z P       //  Curve coordinates
    Gy : Z P       //    of generator point

type Point = (Z P, Z P)
G = (Gx, Gy) : Point
a = -3 : Z P
p = toInteger`{width P} `P

private
    even k = k % 2 == 0

// Calulate x / y in F_p using Euler's binary gcd algorithm
moddiv : {p}(fin p, p >= 3) => Z p -> Z p -> Z p  // p prime!
moddiv x y = if y == 0 then error "division by 0"  // zero has no inverse
                       else fromInteger (egcd `p 0 (fromZ y) (fromZ x))
    where

    egcd : Integer -> Integer -> Integer -> Integer -> Integer
    egcd aa ra bb rb =  // aa odd!
        if bb == 0 then ra
         | even bb then egcd aa ra (   bb     / 2) (half rb)
         | aa < bb then egcd aa ra ((bb - aa) / 2) (half ((rb - ra) % `p))
                   else egcd bb rb ((aa - bb) / 2) (half ((ra - rb) % `p))

    half : Integer -> Integer
    half k = (if k % 2 == 0 then k else (k + `p)) / 2

(%/) = moddiv  // infix form of operator

// A convenient representation of the point-at-infinity identity element
oo = (0, 0) : Point

// Check that a given point is on the curve
valid_point : Point -> Bit
valid_point (x, y) =
    ((x, y) == oo) \/ (y ^^ 2 == x ^^ 3 + a * x + b)

// (From http://www.secg.org/sec1-v2.pdf, section 2.2.1)
// Addition of two elliptic curve points in E(F_p) (p an odd prime)
// on a curve with coefficient 'a'. Note 'b' is unused.
ec_add : Point -> Point -> Point
ec_add (x1, y1) (x2, y2) = 
    if (x1, y1) ==    oo     then  (x2, y2)  //  Rules 1, 2
     | (x2, y2) ==    oo     then  (x1, y1)  //  Rules 1, 2
     | (x1, y1) == (x2, -y1) then     oo     //  Rule 3
                             else   (x, y)   //  Rules 4, 5 
    where  // all arithmetic operations are mod p
    x = L ^^ 2 - x1 - x2
    y = L * (x1 - x) - y1
    L = if x1 == x2 then (3 * x1 ^^ 2 + a) %/ (2 * y1)
                    else (y2 - y1) %/ (x2 - x1)

// Scalar multiplication of a curve point using double-and-add
scmul : Integer -> Point -> Point
scmul m xy =
    if m == 0 then oo
     | m == 1 then xy
     | even m then scmul (m / 2) (ec_add xy xy)
              else ec_add xy (scmul (m - 1) xy)

(~*) = scmul  // infix form of operator

// TODO: needs a primality checker!
// property p_prime = prime p
// property n_prime = prime n
property valid_n = (n + 1) ~* G == G
property valid_scmul m = valid_point (m ~* G)
property scmul_commutes m m' = m ~* (m' ~* G) == m' ~* (m ~* G)
